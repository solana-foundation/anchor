#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

function usage() {
  console.error("Mock anchor CLI: unsupported command");
  process.exit(1);
}

function ensureFile(fp) {
  if (!fp) {
    console.error("Error: --filepath is required");
    process.exit(1);
  }

  if (!fs.existsSync(fp)) {
    console.error("Error: IDL doesn't exist");
    process.exit(1);
  }

  try {
    JSON.parse(fs.readFileSync(fp, "utf8"));
  } catch (err) {
    console.error(`Error: Failed to parse IDL JSON: ${err.message}`);
    process.exit(1);
  }
}

function handleIdlInit(args) {
  let filepath;
  let priorityFee;
  const positional = [];

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--filepath") {
      filepath = args[++i];
    } else if (arg === "--priority-fee") {
      priorityFee = args[++i];
    } else {
      positional.push(arg);
    }
  }

  const programId = positional[positional.length - 1];
  if (!programId) {
    console.error("Error: PROGRAM_ID argument required");
    process.exit(1);
  }

  ensureFile(filepath);

  if (priorityFee) {
    process.stdout.write(`Using priority fee: ${priorityFee}\n`);
  }

  const idlAddress =
    process.env.MOCK_ANCHOR_IDL_ACCOUNT ||
    "Fg6PaFpoGXkYsidMpWxTWqk2b9G8mCe3bHp9Cne9dtrT";

  process.stdout.write(`Idl account created: ${idlAddress}\n`);
}

function handleIdlFetch(args) {
  let outPath;
  const positional = [];

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "-o" || arg === "--out") {
      outPath = args[++i];
    } else {
      positional.push(arg);
    }
  }

  const address = positional[0];
  if (!address) {
    console.error("Error: ADDRESS argument required");
    process.exit(1);
  }

  const expectedAddress = process.env.MOCK_IDL_FETCH_EXPECT_ADDRESS;
  if (expectedAddress && expectedAddress !== address) {
    console.error(`Unexpected fetch address: ${address}`);
    process.exit(1);
  }

  const errorMessage = process.env.MOCK_IDL_FETCH_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_IDL_FETCH_EXIT_CODE ?? "1",
      10,
    );
    console.error(errorMessage);
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  let payload = process.env.MOCK_IDL_FETCH_INLINE_JSON;
  const sourcePath = process.env.MOCK_IDL_FETCH_SOURCE;
  if (sourcePath) {
    try {
      payload = fs.readFileSync(sourcePath, "utf8");
    } catch (err) {
      console.error(`Error: Failed to read IDL fixture: ${err.message}`);
      process.exit(1);
    }
  }

  if (!payload) {
    payload = JSON.stringify({ name: "mock_idl" });
  }

  let parsed;
  try {
    parsed = JSON.parse(payload);
  } catch (err) {
    console.error(`Error: Failed to parse IDL JSON: ${err.message}`);
    process.exit(1);
  }

  const formatted = `${JSON.stringify(parsed, null, 2)}\n`;

  if (outPath) {
    fs.mkdirSync(path.dirname(outPath), { recursive: true });
    fs.writeFileSync(outPath, formatted);
  } else {
    process.stdout.write(formatted);
  }

  const logPath = process.env.MOCK_IDL_FETCH_LOG_PATH;
  if (logPath) {
    const logEntry = {
      command: "anchor idl fetch",
      address,
      out: outPath ?? null,
    };
    fs.appendFileSync(logPath, JSON.stringify(logEntry) + "\n");
  }
}

function handleIdlUpgrade(args) {
  let filepath;
  let priorityFee;
  const positional = [];

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--filepath" || arg === "-f") {
      filepath = args[++i];
    } else if (arg === "--priority-fee") {
      priorityFee = args[++i];
    } else {
      positional.push(arg);
    }
  }

  const programId = positional[positional.length - 1];
  if (!programId) {
    console.error("Error: PROGRAM_ID argument required");
    process.exit(1);
  }

  ensureFile(filepath);

  const expectedProgramId = process.env.MOCK_IDL_UPGRADE_EXPECT_PROGRAM_ID;
  if (expectedProgramId && expectedProgramId !== programId) {
    console.error(`Unexpected upgrade program id: ${programId}`);
    process.exit(1);
  }

  const errorMessage = process.env.MOCK_IDL_UPGRADE_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_IDL_UPGRADE_EXIT_CODE ?? "1",
      10,
    );
    console.error(errorMessage);
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  if (priorityFee) {
    process.stdout.write(`Using priority fee: ${priorityFee}\n`);
  }

  const idlAddress =
    process.env.MOCK_IDL_UPGRADE_IDL_ADDRESS ||
    "IdlUpgrade11111111111111111111111111111111";

  process.stdout.write(`Idl account ${idlAddress} successfully upgraded\n`);
}

function handleIdlAuthority(args) {
  const positional = [...args];
  const programId = positional[0];

  if (!programId) {
    console.error("Error: PROGRAM_ID argument required");
    process.exit(1);
  }

  const expectedAddress = process.env.MOCK_IDL_AUTHORITY_EXPECT_ADDRESS;
  if (expectedAddress && expectedAddress !== programId) {
    console.error(`Unexpected authority address: ${programId}`);
    process.exit(1);
  }

  const errorMessage = process.env.MOCK_IDL_AUTHORITY_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_IDL_AUTHORITY_EXIT_CODE ?? "1",
      10,
    );
    console.error(errorMessage);
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  const authority =
    process.env.MOCK_IDL_AUTHORITY_VALUE ||
    "Auth111111111111111111111111111111111111111";

  process.stdout.write(`${authority}\n`);
}

function handleIdlEraseAuthority(args) {
  let programId;
  let priorityFee;

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "-p" || arg === "--program-id") {
      programId = args[++i];
    } else if (arg === "--priority-fee") {
      priorityFee = args[++i];
    }
  }

  if (!programId) {
    console.error("Error: --program-id is required");
    process.exit(1);
  }

  const expectedAddress = process.env.MOCK_IDL_ERASE_EXPECT_ADDRESS;
  if (expectedAddress && expectedAddress !== programId) {
    console.error(`Unexpected erase address: ${programId}`);
    process.exit(1);
  }

  const confirm = process.env.MOCK_IDL_ERASE_CONFIRM ?? "y";
  process.stdout.write("Are you sure you want to erase the IDL authority: [y/n]\n");
  if (confirm !== "y") {
    process.stdout.write("Not erasing.\n");
    return;
  }

  const errorMessage = process.env.MOCK_IDL_ERASE_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_IDL_ERASE_EXIT_CODE ?? "1",
      10,
    );
    console.error(errorMessage);
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  if (priorityFee) {
    process.stdout.write(`Using priority fee: ${priorityFee}\n`);
  }

  process.stdout.write("Authority update complete.\n");
}

function handleIdl(args) {
  const subcommand = args.shift();

  switch (subcommand) {
    case "init":
      handleIdlInit(args);
      break;
    case "fetch":
      handleIdlFetch(args);
      break;
    case "upgrade":
      handleIdlUpgrade(args);
      break;
    case "erase-authority":
      handleIdlEraseAuthority(args);
      break;
    case "authority":
      handleIdlAuthority(args);
      break;
    default:
      usage();
  }
}

function handleKeysList(args) {
  const errorMessage = process.env.MOCK_KEYS_LIST_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_KEYS_LIST_EXIT_CODE ?? "1",
      10,
    );
    console.error(errorMessage);
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  const programsJson = process.env.MOCK_KEYS_LIST_PROGRAMS;
  if (programsJson) {
    try {
      const programs = JSON.parse(programsJson);
      for (const program of programs) {
        process.stdout.write(`${program.name}: ${program.pubkey}\n`);
      }
    } catch (err) {
      console.error(`Error: Failed to parse MOCK_KEYS_LIST_PROGRAMS: ${err.message}`);
      process.exit(1);
    }
  }

  const logPath = process.env.MOCK_KEYS_LIST_LOG_PATH;
  if (logPath) {
    const logEntry = {
      command: "anchor keys list",
    };
    fs.appendFileSync(logPath, JSON.stringify(logEntry) + "\n");
  }
}

function handleKeysSync(args) {
  let programName;

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "-p" || arg === "--program-name") {
      programName = args[++i];
    }
  }

  const errorMessage = process.env.MOCK_KEYS_SYNC_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_KEYS_SYNC_EXIT_CODE ?? "1",
      10,
    );
    console.error(errorMessage);
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  const clusterName = process.env.MOCK_KEYS_SYNC_CLUSTER || "localnet";
  process.stdout.write(`Syncing program ids for the configured cluster (${clusterName})\n\n`);

  const changesMade = process.env.MOCK_KEYS_SYNC_CHANGES_MADE === "true";
  const sourceChanges = process.env.MOCK_KEYS_SYNC_SOURCE_CHANGES;
  const tomlChanges = process.env.MOCK_KEYS_SYNC_TOML_CHANGES;

  if (sourceChanges) {
    try {
      const changes = JSON.parse(sourceChanges);
      for (const change of changes) {
        process.stdout.write(`Found incorrect program id declaration in ${change.file}\n`);
        process.stdout.write(`Updated to ${change.newId}\n\n`);
      }
    } catch (err) {
      console.error(`Error: Failed to parse MOCK_KEYS_SYNC_SOURCE_CHANGES: ${err.message}`);
      process.exit(1);
    }
  }

  if (tomlChanges) {
    try {
      const changes = JSON.parse(tomlChanges);
      for (const change of changes) {
        process.stdout.write(`Found incorrect program id declaration in Anchor.toml for the program \`${change.program}\`\n`);
        process.stdout.write(`Updated to ${change.newId}\n\n`);
      }
    } catch (err) {
      console.error(`Error: Failed to parse MOCK_KEYS_SYNC_TOML_CHANGES: ${err.message}`);
      process.exit(1);
    }
  }

  process.stdout.write("All program id declarations are synced.");
  if (changesMade) {
    process.stdout.write("\nPlease rebuild the program to update the generated artifacts.");
  }
  process.stdout.write("\n");

  const logPath = process.env.MOCK_KEYS_SYNC_LOG_PATH;
  if (logPath) {
    const logEntry = {
      command: "anchor keys sync",
      programName: programName ?? null,
    };
    fs.appendFileSync(logPath, JSON.stringify(logEntry) + "\n");
  }
}

function handleKeys(args) {
  const subcommand = args.shift();

  switch (subcommand) {
    case "list":
      handleKeysList(args);
      break;
    case "sync":
      handleKeysSync(args);
      break;
    default:
      usage();
  }
}

function handleTest(args) {
  // Parse command line flags
  let programName;
  let skipDeploy = false;
  let skipBuild = false;
  let skipValidator = false;
  
  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "-p" || arg === "--program-name") {
      programName = args[++i];
    } else if (arg === "--skip-deploy") {
      skipDeploy = true;
    } else if (arg === "--skip-build") {
      skipBuild = true;
    } else if (arg === "--skip-local-validator") {
      skipValidator = true;
    }
  }

  // Check for error conditions
  const errorMessage = process.env.MOCK_ANCHOR_TEST_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_ANCHOR_TEST_EXIT_CODE ?? "1",
      10,
    );
    process.stderr.write(errorMessage + "\n");
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  // Validate expected flags
  const expectedSkipDeploy = process.env.MOCK_ANCHOR_TEST_SKIP_DEPLOY === "true";
  if (expectedSkipDeploy !== skipDeploy) {
    process.stderr.write(`Error: Unexpected skip-deploy flag state\n`);
    process.exit(1);
  }

  const expectedSkipBuild = process.env.MOCK_ANCHOR_TEST_SKIP_BUILD === "true";
  if (expectedSkipBuild !== skipBuild) {
    process.stderr.write(`Error: Unexpected skip-build flag state\n`);
    process.exit(1);
  }

  const expectedProgramName = process.env.MOCK_ANCHOR_TEST_PROGRAM_NAME;
  if (expectedProgramName && programName !== expectedProgramName) {
    process.stderr.write(`Error: Unexpected program name: ${programName}\n`);
    process.exit(1);
  }

  // Generate test output
  const customOutput = process.env.MOCK_ANCHOR_TEST_OUTPUT;
  if (customOutput) {
    process.stdout.write(customOutput + "\n");
  } else {
    // Default test success output
    if (!skipBuild) {
      process.stdout.write("Building programs...\n");
    }
    if (!skipDeploy) {
      process.stdout.write("Deploying programs...\n");
    }
    if (!skipValidator) {
      process.stdout.write("Starting local test validator...\n");
    }
    process.stdout.write("\n  test-program\n");
    process.stdout.write("    âœ” Is initialized!\n\n");
    process.stdout.write("  1 passing\n");
  }

  const logPath = process.env.MOCK_ANCHOR_TEST_LOG_PATH;
  if (logPath) {
    const logEntry = {
      command: "anchor test",
      programName: programName ?? null,
      skipDeploy,
      skipBuild,
      skipValidator,
    };
    fs.appendFileSync(logPath, JSON.stringify(logEntry) + "\n");
  }
}

function handleMigrate(args) {
  // Check for error conditions
  const errorMessage = process.env.MOCK_ANCHOR_MIGRATE_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_ANCHOR_MIGRATE_EXIT_CODE ?? "1",
      10,
    );
    process.stderr.write(errorMessage + "\n");
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  // Check if migration script should exist
  const scriptExists = process.env.MOCK_ANCHOR_MIGRATE_SCRIPT_EXISTS !== "false";
  if (!scriptExists) {
    process.stderr.write("Error: Migration script not found\n");
    process.exit(1);
  }

  // Determine if using TypeScript or JavaScript
  const useTs = process.env.MOCK_ANCHOR_MIGRATE_USE_TS === "true";

  // Generate migration output
  const customOutput = process.env.MOCK_ANCHOR_MIGRATE_OUTPUT;
  if (customOutput) {
    process.stdout.write(customOutput + "\n");
  } else {
    // Default migration success output
    process.stdout.write("Running migration deploy script\n");
    if (useTs) {
      process.stdout.write("Using TypeScript migration script\n");
    } else {
      process.stdout.write("Using JavaScript migration script\n");
    }
    process.stdout.write("\nDeploy complete.\n");
  }

  const logPath = process.env.MOCK_ANCHOR_MIGRATE_LOG_PATH;
  if (logPath) {
    const logEntry = {
      command: "anchor migrate",
      useTs,
    };
    fs.appendFileSync(logPath, JSON.stringify(logEntry) + "\n");
  }
}

function handleVerify(args) {
  // Check for error conditions
  const errorMessage = process.env.MOCK_ANCHOR_VERIFY_ERROR;
  if (errorMessage) {
    const exitCode = Number.parseInt(
      process.env.MOCK_ANCHOR_VERIFY_EXIT_CODE ?? "1",
      10,
    );
    process.stderr.write(errorMessage + "\n");
    process.exit(Number.isNaN(exitCode) ? 1 : exitCode);
  }

  // Parse program ID (first argument)
  if (args.length === 0) {
    process.stderr.write("Error: Program ID is required\n");
    process.exit(1);
  }

  const programId = args[0];
  const remainingArgs = args.slice(1);

  // Check if required arguments are provided
  const hasCurrentDir = remainingArgs.includes("--current-dir");
  const repoUrlIndex = remainingArgs.indexOf("--repo-url");
  const hasRepoUrl = repoUrlIndex !== -1;

  if (!hasCurrentDir && !hasRepoUrl) {
    process.stderr.write(
      "Error: You must provide either --repo-url or --current-dir\n",
    );
    process.exit(1);
  }

  // Print verification message
  process.stdout.write(`Verifying program ${programId}\n`);

  // Find solana-verify in PATH
  const solanaVerifyPath = process.env.MOCK_SOLANA_VERIFY_PATH || "solana-verify";

  // Build solana-verify command arguments
  const verifyArgs = ["verify-from-repo"];

  // Handle current-dir or repo-url
  if (hasCurrentDir) {
    verifyArgs.push(process.cwd());
    verifyArgs.push("--current-dir");
  } else if (hasRepoUrl && repoUrlIndex + 1 < remainingArgs.length) {
    const repoUrl = remainingArgs[repoUrlIndex + 1];
    verifyArgs.push(repoUrl);
  }

  // Add commit-hash if present
  const commitHashIndex = remainingArgs.indexOf("--commit-hash");
  if (commitHashIndex !== -1 && commitHashIndex + 1 < remainingArgs.length) {
    verifyArgs.push("--commit-hash");
    verifyArgs.push(remainingArgs[commitHashIndex + 1]);
  }

  // Add program-name (library-name) if present
  const programNameIndex = remainingArgs.indexOf("--program-name");
  if (programNameIndex !== -1 && programNameIndex + 1 < remainingArgs.length) {
    verifyArgs.push("--library-name");
    verifyArgs.push(remainingArgs[programNameIndex + 1]);
  }

  // Add program-id
  verifyArgs.push("--program-id");
  verifyArgs.push(programId);

  // Execute solana-verify
  const { spawnSync } = require("child_process");
  const result = spawnSync(solanaVerifyPath, verifyArgs, {
    stdio: "inherit",
    env: process.env,
  });

  if (result.error) {
    process.stderr.write(
      `Error: Failed to run \`solana-verify\`: ${result.error.message}\n`,
    );
    process.exit(1);
  }

  if (result.status !== 0) {
    process.stderr.write("Error: Failed to verify program\n");
    process.exit(result.status || 1);
  }
}

function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) {
    usage();
  }

  const command = args.shift();

  switch (command) {
    case "build":
      process.stdout.write("Anchor build (mock) succeeded\n");
      break;
    case "deploy":
      process.stdout.write("Anchor deploy (mock) succeeded\n");
      break;
    case "idl":
      handleIdl(args);
      break;
    case "keys":
      handleKeys(args);
      break;
    case "test":
      handleTest(args);
      break;
    case "migrate":
      handleMigrate(args);
      break;
    case "verify":
      handleVerify(args);
      break;
    default:
      usage();
  }
}

main();

